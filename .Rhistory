qlf <- glmQLFit(fit)
# Results table
tt <- topTags(qlf, n=nrow(y), sort.by="none") # extracts the most differentially expressed genes from a test object
head(tt$table[order(tt$table$FDR, decreasing=FALSE), ])
y <- estimateDisp(y, design) # with replicates
# Quasi-likelihood F test
qlf <- glmQLFit(y, design)
tt <- topTags(qlf, n=nrow(y), sort.by="none") # extracts the most differentially expressed genes from a test object
head(tt$table[order(tt$table$FDR, decreasing=FALSE), ])
y <- estimateDisp(y, design) # with replicates
fit <- glmQLFit(y, design)
# Quasi-likelihood F test
qlf <- glmQLFTest(fit, coef=2)
tt <- topTags(qlf, n=nrow(y), sort.by="none") # extracts the most differentially expressed genes from a test object
head(tt$table[order(tt$table$FDR, decreasing=FALSE), ])
pscnt <- 2
NLex <- log2(Nex + pscnt)
NLin <- log2(Nin + pscnt)
#### Filtering ####
# Identifying and filtering genes with low counts in introns or exons
length(rownames(exon))
quantGenes <- rownames(exon)[rowMeans(NLex) > 5.0 & rowMeans(NLin) > 5.0]
length(quantGenes)
#### Calculating changes in exon/intron counts between conditions ####
# Need to generalise here for sample name format:
Dex <- NLex[, c("THAP_RNAseq_rep1",
"THAP_RNAseq_rep2",
"THAP_RNAseq_rep3",
"THAP_RNAseq_rep4")] - NLex[, c("DMSO_RNAseq_rep1",
"DMSO_RNAseq_rep2",
"DMSO_RNAseq_rep3",
"DMSO_RNAseq_rep4")]
Din <- NLin[, c("THAP_RNAseq_rep1",
"THAP_RNAseq_rep2",
"THAP_RNAseq_rep3",
"THAP_RNAseq_rep4")] - NLex[, c("DMSO_RNAseq_rep1",
"DMSO_RNAseq_rep2",
"DMSO_RNAseq_rep3",
"DMSO_RNAseq_rep4")]
Dex.Din <- Dex - Din # changes in counts attributable to post-transcriptional regulation
# Apply filter on deltas
cor(Dex[quantGenes, 1], Dex[quantGenes, 2])
cor(Din[quantGenes, 1], Din[quantGenes, 2])
cor(Dex.Din[quantGenes,1], Dex.Din[quantGenes,2])
#### Statistical analysis with edgeR framework ####
# Convert count tables to DGEList
counts <- data.frame(Ex=exon, In=intron) # merge intron and exon count tables
y <- DGEList(counts=counts,
genes=data.frame(ENTREZID=rownames(counts)))
# Filter and normalise
y <- y[quantGenes, ]
y <- calcNormFactors(y) # normalises library sizes by finding a set of scaling factors for the library sizes that minimizes log-fold changes between samples for most genes
# Design matrix with interaction term
region <- factor(c(rep("ex", 8), rep("in", 8)),
levels=c("in", "ex"))
cond <- rep(factor(c(rep("DMSO", 4), rep("THAP", 4))), 2) # contrast will be THAP - DMSO
design <- model.matrix(~ region * cond)
rownames(design) <- colnames(counts)
# Estimate model parameters and fit linear model
y <- estimateDisp(y, design) # with replicates
fit <- glmQLFit(y, design)
# Quasi-likelihood F test
qlf <- glmQLFTest(fit, coef=2)
# Results table
tt <- topTags(qlf, n=nrow(y), sort.by="none") # extracts the most differentially expressed genes from a test object
head(tt$table[order(tt$table$FDR, decreasing=FALSE), ])
help(gsub)
region
cond
region <- factor(c(rep("ex", 8), rep("in", 8)),
levels=c("in", "ex"))
cond <- rep(factor(c(rep("DMSO", 4), rep("THAP", 4))), 2) # contrast will be THAP - DMSO
sample <- rep(factor(c("smpls001", "smpls002", "smpls003", "smpls004", "smpls005", "smpls006", "smpls007", "smpls008")), 2)
design <- model.matrix(~ sample + region * cond)
rownames(design) <- colnames(counts)
design
region <- factor(c(rep("ex", 8), rep("in", 8)),
levels=c("in", "ex"))
cond <- rep(factor(c(rep("DMSO", 4), rep("THAP", 4))), 2) # contrast will be THAP - DMSO
smpls <- rep(factor(c("001", "002", "003", "004", "005", "006", "007", "008")), 2)
design <- model.matrix(~ smpls + region * cond)
rownames(design) <- colnames(counts)
design
region <- factor(c(rep("ex", 8), rep("in", 8)),
levels=c("in", "ex"))
cond <- rep(factor(c(rep("DMSO", 4), rep("THAP", 4))), 2) # contrast will be THAP - DMSO
smpls <- rep(factor(c("001", "002", "003", "004", "005", "006", "007", "008")), 2)
design <- model.matrix(~ smpls + cond * region)
rownames(design) <- colnames(counts)
design
region <- factor(c(rep("ex", 8), rep("in", 8)),
levels=c("in", "ex"))
cond <- factor(c(rep("DMSO", 4), rep("THAP", 4))) # contrast will be THAP - DMSO
smpls <- rep(factor(c("001", "002", "003", "004", "005", "006", "007", "008")), 2)
design <- model.matrix(~ smpls + cond * region)
rownames(design) <- colnames(counts)
region <- factor(c(rep("ex", 8), rep("in", 8)),
levels=c("in", "ex"))
cond <- factor(rep(c(rep("DMSO", 4), rep("THAP", 4),2))) # contrast will be THAP - DMSO
smpls <- rep(factor(c("001", "002", "003", "004", "005", "006", "007", "008")), 2)
design <- model.matrix(~ smpls + cond * region)
rownames(design) <- colnames(counts)
cond
region <- factor(c(rep("ex", 8), rep("in", 8)),
levels=c("in", "ex"))
cond <- rep(factor(c(rep("DMSO", 4), rep("THAP", 4))), 2) # contrast will be THAP - DMSO
smpls <- rep(factor(c("001", "002", "003", "004", "005", "006", "007", "008")), 2)
design <- model.matrix(~ smpls + cond * region)
rownames(design) <- colnames(counts)
rep
cond
region <- factor(c(rep("ex", 8), rep("in", 8)),
levels=c("in", "ex"))
cond <- rep(factor(c(rep("DMSO", 4), rep("THAP", 4))), 2) # contrast will be THAP - DMSO
smpls <- rep(factor(c("001", "002", "003", "004", "005", "006", "007", "008")), 2)
design <- model.matrix(~ smpls + (cond * region))
rownames(design) <- colnames(counts)
design
region <- factor(c(rep("ex", 8), rep("in", 8)),
levels=c("in", "ex"))
c <- rep(factor(c(rep("DMSO", 4), rep("THAP", 4))), 2) # contrast will be THAP - DMSO
smpls <- rep(factor(c("001", "002", "003", "004", "005", "006", "007", "008")), 2)
design <- model.matrix(~ smpls + (c * region))
rownames(design) <- colnames(counts)
region <- factor(c(rep("ex", 8), rep("in", 8)),
levels=c("in", "ex"))
c <- rep(factor(c(rep(1, 4), rep(2, 4))), 2) # contrast will be THAP - DMSO
smpls <- rep(factor(c("001", "002", "003", "004", "005", "006", "007", "008")), 2)
design <- model.matrix(~ smpls + (c * region))
rownames(design) <- colnames(counts)
design
region <- factor(c(rep("ex", 8), rep("in", 8)),
levels=c("in", "ex"))
c <- rep(factor(c(rep(1, 4), rep(2, 4))), 2) # contrast will be THAP - DMSO
smpls <- rep(factor(c("001", "002", "003", "004", "005", "006", "007", "008")), 2)
design <- model.matrix(~ smpls + (c * region) + 0)
rownames(design) <- colnames(counts)
design
region <- factor(c(rep("ex", 8), rep("in", 8)),
levels=c("in", "ex"))
c <- rep(factor(c(rep(1, 4), rep(2, 4))), 2) # contrast will be THAP - DMSO
smpls <- rep(factor(c("001", "002", "003", "004", "005", "006", "007", "008")), 2)
design <- model.matrix(~ smpls + (c + 0) * (region + 0))
rownames(design) <- colnames(counts)
design
region <- factor(c(rep("ex", 8), rep("in", 8)),
levels=c("in", "ex"))
c <- rep(factor(c(rep(1, 4), rep(2, 4))), 2) # contrast will be THAP - DMSO
smpls <- rep(factor(c("001", "002", "003", "004", "005", "006", "007", "008")), 2)
design <- model.matrix(~ smpls + (c * region + 0))
rownames(design) <- colnames(counts)
design
smpls <- rep(factor(c("001", "002", "003", "004", "005", "006", "007", "008")), 2)
region <- factor(c(rep("ex", 8), rep("in", 8)),
levels=c("in"))
c <- rep(factor(c(rep(1, 4), rep(2, 4))), 2) # contrast will be THAP - DMSO
design <- model.matrix(~ smpls + (c * region))
rownames(design) <- colnames(counts)
# Estimate model parameters and fit linear model
y <- estimateDisp(y, design) # with replicates
fit <- glmQLFit(y, design)
# Quasi-likelihood F test
qlf <- glmQLFTest(fit, coef=2)
# Design matrix with interaction term
smpls <- rep(factor(c("001", "002", "003", "004", "005", "006", "007", "008")), 2)
region <- factor(c(rep("ex", 8), rep("in", 8)),
levels=c("in", "ex"))
c <- rep(factor(c(rep(1, 4), rep(2, 4))), 2) # contrast will be THAP - DMSO
design <- model.matrix(~ smpls + (c * region))
rownames(design) <- colnames(counts)
# Estimate model parameters and fit linear model
y <- estimateDisp(y, design) # with replicates
fit <- glmQLFit(y, design)
# Quasi-likelihood F test
qlf <- glmQLFTest(fit, coef=2)
smpls <- rep(factor(c("001", "002", "003", "004", "005", "006", "007", "008")), 2)
region <- factor(c(rep("ex", 8), rep("in", 8)),
levels=c("in", "ex"))
c <- rep(factor(c(rep(1, 4), rep(2, 4))), 2) # contrast will be THAP - DMSO
design <- model.matrix(~ smpls + (c * region))
rownames(design) <- colnames(counts)
# Estimate model parameters and fit linear model
y <- estimateDisp(y, design) # with replicates
fit <- glmQLFit(y, design)
# Quasi-likelihood F test
qlf <- glmQLFTest(fit, coef=2)
region <- factor(c(rep("ex", 8), rep("in", 8)),
levels=c("in", "ex"))
c <- rep(factor(c(rep(1, 4), rep(2, 4))), 2) # contrast will be THAP - DMSO
design <- model.matrix(~ smpls + (c * region))
rownames(design) <- colnames(counts)
design
smpls <- rep(factor(c("001", "002", "003", "004", "005", "006", "007", "008")), 2)
region <- factor(c(rep("ex", 8), rep("in", 8)),
levels=c("in", "ex"))
c <- rep(factor(c(rep(1, 4), rep(2, 4))), 2) # contrast will be THAP - DMSO
design <- model.matrix(~ smpls + ((c - 1) * (region - 1)))
rownames(design) <- colnames(counts)
design
smpls <- rep(factor(c("001", "002", "003", "004", "005", "006", "007", "008")), 2)
region <- factor(c(rep("ex", 8), rep("in", 8)),
levels=c("in", "ex"))
c <- rep(factor(c(rep(1, 4), rep(2, 4))), 2) # contrast will be THAP - DMSO
design <- model.matrix(~ smpls + ((c + 0) * (region + 0)))
rownames(design) <- colnames(counts)
design
smpls <- rep(factor(c("001", "002", "003", "004", "005", "006", "007", "008")), 2)
region <- factor(c(rep("ex", 8), rep("in", 8)),
levels=c("in", "ex"))
c <- rep(factor(c(rep(1, 4), rep(2, 4))), 2) # contrast will be THAP - DMSO
design <- model.matrix(~ smpls + ((c * region)^2))
rownames(design) <- colnames(counts)
design
design <- model.matrix(~ smpls + ((c + region)^2))
rownames(design) <- colnames(counts)
design
design <- model.matrix(~ smpls + (c + region)^2)
rownames(design) <- colnames(counts)
design
smpls <- rep(factor(c("001", "002", "003", "004", "005", "006", "007", "008")), 2)
c <- factor(c(rep("1.ex", 4), rep("2.ex", 4), rep("1.in", 4), rep("2.in", 4)))
design <- model.matrix(~ smpls + c)
rownames(design) <- colnames(counts)
design
smpls <- rep(factor(c("001", "002", "003", "004", "005", "006", "007", "008")), 2)
c <- factor(c(rep("1.ex", 4), rep("2.ex", 4), rep("1.in", 4), rep("2.in", 4)),
levels=c("1.in", "2.in", "1.ex", "2.ex"))
design <- model.matrix(~ smpls + c)
rownames(design) <- colnames(counts)
design
smpls <- rep(factor(c("001", "002", "003", "004", "005", "006", "007", "008")), 2)
c <- factor(c(rep("1.ex", 4), rep("2.ex", 4), rep("1.in", 4), rep("2.in", 4)),
levels=c("1.in", "2.in", "1.ex", "2.ex"))
design <- model.matrix(~ smpls + c)
design <- design[, -9]
rownames(design) <- colnames(counts)
design
y <- estimateDisp(y, design) # with replicates
fit <- glmQLFit(y, design)
qlf <- glmQLFTest(fit, coef=2)
tt <- topTags(qlf, n=nrow(y), sort.by="none") # extracts the most differentially expressed genes from a test object
head(tt$table[order(tt$table$FDR, decreasing=FALSE), ])
sig <- tt$table$FDR < 0.05
sum(sig)
typeof(sig)
tt$table
library(edgeR)
library(eisaR)
library(ggplot2)
library(dplyr)
ggplot(data=sig, aes(x=logCPM, y=logFC)) +
geom_point(color="lightgrey") +
geom_point(data=sig %>% dplyr::filter(FDR < 0.05),
color="red") +
theme_bw()
ggplot(data=tt$table, aes(x=logCPM, y=logFC)) +
geom_point(color="lightgrey") +
geom_point(data=tt$table %>% dplyr::filter(FDR < 0.05),
color="red") +
theme_bw()
smpls <- rep(factor(c("001", "002", "003", "004", "005", "006", "007", "008")), 2)
c <- factor(c(rep("1.ex", 4), rep("2.ex", 4), rep("1.in", 4), rep("2.in", 4)),
levels=c("1.in", "2.in", "1.ex", "2.ex"))
design <- model.matrix(~ smpls + c)
design <- design[, -9]
rownames(design) <- colnames(counts)
# Log transformation (with pseudocount 2)
logFC <- predFC(y, design, prior.count=2)
# Estimate model parameters and fit linear model
y <- estimateDisp(y, design) # with replicates
fit <- glmQLFit(y, design)
# Quasi-likelihood F test
qlf <- glmQLFTest(fit, coef=2)
# Results table
tt <- topTags(qlf, n=nrow(y), sort.by="none") # extracts the most differentially expressed genes from a test object
head(tt$table[order(tt$table$FDR, decreasing=FALSE), ])
#### Result Visualisation ####
sig <- tt$table$FDR < 0.05
sum(sig)
# Volcano plot
# Delta I vs. Delta E
# MA plot
ggplot(data=tt$table, aes(x=logCPM, y=logFC)) +
geom_point(color="lightgrey") +
geom_point(data=tt$table %>% dplyr::filter(FDR < 0.05),
color="red") +
theme_bw()
counts <- data.frame(Ex=exon, In=intron) # merge intron and exon count tables
y <- DGEList(counts=counts,
genes=data.frame(ENTREZID=rownames(counts)))
# Filter and normalise
# y <- y[quantGenes, ]
y <- calcNormFactors(y) # normalises library sizes by finding a set of scaling factors for the library sizes that minimizes log-fold changes between samples for most genes
y <- filterByExpr(y)
# Design matrix with interaction term
smpls <- rep(factor(c("001", "002", "003", "004", "005", "006", "007", "008")), 2)
c <- factor(c(rep("1.ex", 4), rep("2.ex", 4), rep("1.in", 4), rep("2.in", 4)),
levels=c("1.in", "2.in", "1.ex", "2.ex"))
design <- model.matrix(~ smpls + c)
design <- design[, -9]
rownames(design) <- colnames(counts)
# Log transformation (with pseudocount 2)
logFC <- predFC(y, design, prior.count=2)
# Estimate model parameters and fit linear model
y <- estimateDisp(y, design) # with replicates
fit <- glmQLFit(y, design)
# Quasi-likelihood F test
qlf <- glmQLFTest(fit, coef=2)
# Results table
tt <- topTags(qlf, n=nrow(y), sort.by="none") # extracts the most differentially expressed genes from a test object
head(tt$table[order(tt$table$FDR, decreasing=FALSE), ])
#### Result Visualisation ####
sig <- tt$table$FDR < 0.05
sum(sig)
# Volcano plot
# Delta I vs. Delta E
# MA plot
ggplot(data=tt$table, aes(x=logCPM, y=logFC)) +
geom_point(color="lightgrey") +
geom_point(data=tt$table %>% dplyr::filter(FDR < 0.05),
color="red") +
theme_bw()
logFC
tt$table$logFC
region <- factor(c(rep("ex", 8), rep("in", 8)), levels=c("in", "ex"))
cond <- rep(factor(c(rep("DMSO", 4), rep("THAP", 4))), 2)
design2 <- model.matrix(~ region * cond)
logFC <- predFC(y, design2, prior.count=2) # use simpler model matrix
design2
typeof(design2)
region <- factor(c(rep("ex", 8), rep("in", 8)), levels=c("in", "ex"))
cond <- rep(factor(c(rep("DMSO", 4), rep("THAP", 4))), 2)
design2 <- model.matrix(~ region * cond)
rownames(design2) <- colnames(counts)
logFC <- predFC(y, design2, prior.count=2) # use simpler model matrix
design
design2
design2
logFC <- predFC(y, design2, prior.count=2)
y
y <- DGEList(counts=counts,
genes=data.frame(ENTREZID=rownames(counts)))
# Filter and normalise
# y <- y[quantGenes, ]
y <- calcNormFactors(y) # normalises library sizes by finding a set of scaling factors for the library sizes that minimizes log-fold changes between samples for most genes
y <- filterByExpr(y)
y
y <- calcNormFactors(y) # normalises library sizes by finding a set of scaling factors for the library sizes that minimizes log-fold changes between samples for most genes
keep <- filterByExpr(y)
y <- y[keep, , keep.lib.sizes=FALSE]
counts <- data.frame(Ex=exon, In=intron) # merge intron and exon count tables
y <- DGEList(counts=counts,
genes=data.frame(ENTREZID=rownames(counts)))
# Filter and normalise
# y <- y[quantGenes, ]
y <- calcNormFactors(y) # normalises library sizes by finding a set of scaling factors for the library sizes that minimizes log-fold changes between samples for most genes
keep <- filterByExpr(y)
y <- y[keep, , keep.lib.sizes=FALSE]
y
region <- factor(c(rep("ex", 8), rep("in", 8)), levels=c("in", "ex"))
cond <- rep(factor(c(rep("DMSO", 4), rep("THAP", 4))), 2)
design2 <- model.matrix(~ region * cond)
rownames(design2) <- colnames(counts)
logFC <- predFC(y, design2, prior.count=2)
logFC
counts <- data.frame(Ex=exon, In=intron) # merge intron and exon count tables
y <- DGEList(counts=counts,
genes=data.frame(ENTREZID=rownames(counts)))
# Filter and normalise
# y <- y[quantGenes, ]
y <- calcNormFactors(y) # normalises library sizes by finding a set of scaling factors for the library sizes that minimizes log-fold changes between samples for most genes
keep <- filterByExpr(y)
y <- y[keep, , keep.lib.sizes=FALSE]
# Design matrix with interaction term
smpls <- rep(factor(c("001", "002", "003", "004", "005", "006", "007", "008")), 2)
c <- factor(c(rep("1.ex", 4), rep("2.ex", 4), rep("1.in", 4), rep("2.in", 4)),
levels=c("1.in", "2.in", "1.ex", "2.ex"))
design <- model.matrix(~ smpls + c)
design <- design[, -9]
rownames(design) <- colnames(counts)
# Log transformation (with pseudocount 2)
region <- factor(c(rep("ex", 8), rep("in", 8)), levels=c("in", "ex"))
cond <- rep(factor(c(rep("DMSO", 4), rep("THAP", 4))), 2)
design2 <- model.matrix(~ region * cond)
rownames(design2) <- colnames(counts)
logFC <- predFC(y, design2, prior.count=2) # use simpler model matrix
# Estimate model parameters and fit linear model
y <- estimateDisp(y, design) # with replicates
fit <- glmQLFit(y, design)
# Quasi-likelihood F test
qlf <- glmQLFTest(fit, coef=2)
# Results table
tt <- topTags(qlf, n=nrow(y), sort.by="none") # extracts the most differentially expressed genes from a test object
head(tt$table[order(tt$table$FDR, decreasing=FALSE), ])
#### Result Visualisation ####
sig <- tt$table$FDR < 0.05
sum(sig)
# Volcano plot
# Delta I vs. Delta E
# MA plot
ggplot(data=tt$table, aes(x=logCPM, y=logFC)) +
geom_point(color="lightgrey") +
geom_point(data=tt$table %>% dplyr::filter(FDR < 0.05),
color="red") +
theme_bw()
tt$table$logFC
summary(logFC)
summary(tt$table$logFC)
y <- calcNormFactors(y) # normalises library sizes by finding a set of scaling factors for the library sizes that minimizes log-fold changes between samples for most genes
keep <- filterByExpr(y)
y <- y[keep, , keep.lib.sizes=FALSE]
y <- calcNormFactors(y) # recalcNormFactAfterFilt=TRUE
# Design matrix with interaction term
smpls <- rep(factor(c("001", "002", "003", "004", "005", "006", "007", "008")), 2)
c <- factor(c(rep("1.ex", 4), rep("2.ex", 4), rep("1.in", 4), rep("2.in", 4)),
levels=c("1.in", "2.in", "1.ex", "2.ex"))
design <- model.matrix(~ smpls + c)
design <- design[, -9]
rownames(design) <- colnames(counts)
# Log transformation (with pseudocount 2)
region <- factor(c(rep("ex", 8), rep("in", 8)), levels=c("in", "ex"))
cond <- rep(factor(c(rep("DMSO", 4), rep("THAP", 4))), 2)
design2 <- model.matrix(~ region * cond)
rownames(design2) <- colnames(counts)
logFC <- predFC(y, design2, prior.count=2) # use simpler model matrix
# Estimate model parameters and fit linear model
y <- estimateDisp(y, design) # with replicates
fit <- glmQLFit(y, design)
# Quasi-likelihood F test
qlf <- glmQLFTest(fit, coef=2)
# Results table
tt <- topTags(qlf, n=nrow(y), sort.by="none") # extracts the most differentially expressed genes from a test object
head(tt$table[order(tt$table$FDR, decreasing=FALSE), ])
#### Result Visualisation ####
sig <- tt$table$FDR < 0.05
sum(sig)
# Volcano plot
# Delta I vs. Delta E
# MA plot
ggplot(data=tt$table, aes(x=logCPM, y=logFC)) +
geom_point(color="lightgrey") +
geom_point(data=tt$table %>% dplyr::filter(FDR < 0.05),
color="red") +
theme_bw()
View(logFC)
View(logFC)
View(tt$table$logFC)
tt
head(tt)
tt <- topTags(qlf, n=nrow(y), sort.by="none") # extracts the most differentially expressed genes from a test object
tt$table$logFC <- logFC
head(tt$table[order(tt$table$FDR, decreasing=FALSE), ])
sig <- tt$table$FDR < 0.05
sum(sig)
# MA plot
ggplot(data=tt$table, aes(x=logCPM, y=logFC)) +
geom_point(color="lightgrey") +
geom_point(data=tt$table %>% dplyr::filter(FDR < 0.05),
color="red") +
theme_bw()
tt$table$logFC
typeof(tt$table$logZFC)
typeof(tt$table$logFC)
typeof(tt$table$logCPM)
typeof(logFC)
tt <- topTags(qlf, n=nrow(y), sort.by="none") # extracts the most differentially expressed genes from a test object
tt$table$logFC <- logFC[, "regionex:condTHAP"]
head(tt$table[order(tt$table$FDR, decreasing=FALSE), ])
sig <- tt$table$FDR < 0.05
sum(sig)
# MA plot
ggplot(data=tt$table, aes(x=logCPM, y=logFC)) +
geom_point(color="lightgrey") +
geom_point(data=tt$table %>% dplyr::filter(FDR < 0.05),
color="red") +
theme_bw()
design2 <- model.matrix(~ c)
rownames(design2) <- colnames(counts)
logFC <- predFC(y, design2, prior.count=2)
View(logFC)
wlf
qlf
design2 <- model.matrix(~ c)
rownames(design2) <- colnames(counts)
logFC <- predFC(y, design2, prior.count=2)
design2 <- model.matrix(~ c)
rownames(design2) <- colnames(counts)
logFC <- predFC(y, design, prior.count=2)
View(logFC)
qlf$coefficients
head(qlf$coefficients)
head(tt$table)
qlf$df.total
# Results table
tt <- topTags(qlf, n=nrow(y), sort.by="none") # extracts the most differentially expressed genes from a test object
head(tt$table[order(tt$table$FDR, decreasing=FALSE), ])
#### Result Visualisation ####
sig <- tt$table$FDR < 0.05
sum(sig)
# MA plot
ggplot(data=tt$table, aes(x=logCPM, y=logFC)) +
geom_point(color="lightgrey") +
geom_point(data=tt$table %>% dplyr::filter(FDR < 0.05),
color="red") +
theme_bw()
# Volcano plot
# Delta I vs. Delta E
View(logFC)
design2 <- model.matrix(~ c)
rownames(design2) <- colnames(counts)
logFC <- predFC(y, design2, prior.count=2) # use simpler model matrix
View(logFC)
