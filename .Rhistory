design=dsgn[nsmpls + seq.int(nsmpls), ])]
pscnt <- 2
NLex <- cpm(y[, seq.int(nsmpls)], log=TRUE, prior.count=pscnt)
NLin <- cpm(y[, seq.int(nsmpls)], log=TRUE, prior.count=pscnt)
y <- y[quantGenes, ]
#### Design matrix and statistical model fitting ####
# Design matrix
cond2 <- rep(cond, 2L)
region <- factor(rep(c("ex", "in"), each=nsmpls),
levels=c("ex", "in"))
smpl <- factor(rep(sprintf("s%03d", seq.int(nsmpls)), 2)) # formatting strings
dsgn <- model.matrix(~ smpl)
c1.ex <- cond2 == levels(cond2)[1] & region == "ex"
c2.ex <- cond2 == levels(cond2)[2] & region == "ex"
dsgn <- cbind(dsgn, c1.ex, c2.ex)
rownames(dsgn) <- colnames(cnt)
# Fit statistical model
y <- estimateDisp(y, dsgn)
# Build contrast
contr <- (colnames(dsgn) == "c2.ex") - (colnames(dsgn) == "c1.ex")
# Quasi-likelihood F test
fit <- glmQLFit(y, dsgn)
tst.ExIn <- glmQLFTest(fit, contrast=contr)
tt.ExIn <- topTags(tst.ExIn, n=nrow(y), sort.by="none")
#### Calculate log-fold changes ####
lfc <- predFC(y, dsgn, prior.count=pscnt)
rownames(lfc) <- rownames(y)
# Changes in introns and/or exons between THAP vs. DMSO conditions
Dex <- rowSums(lfc[, c(3, 4)])
Din <- lfc[, 3]
Dex.Din <- lfc[, ncol(lfc)]
#### Visualisation ####
# Visualise design matrix
VisualizeDesign(
sampleData=data.frame(
treatment=str_extract(rownames(dsgn), "DMSO|THAP"),
ctype=str_extract(rownames(dsgn), "Ex|In"),
sample=gsub("Ex.|In.", "", rownames(dsgn)),
row.names=rownames(dsgn)
),
designFormula=NULL,
designMatrix=dsgn
)
ggplot(tt.ExIn$table, aes(x=logCPM, y=logFC)) +
geom_point(color="lightgrey") +
geom_point(data=tt.ExIn$table %>% filter(FDR < 0.05), color="red") +
theme_bw()
lfc[, ncol(lfc)]
# Set size factor as exon
y$samples$norm.factors <- y$samples$norm.factors.exons # recalcNormFactAfterFilt=TRUE
# y$samples$lib.size <- y$samples$lib.size.exons # recalcLibSizeAfterFilt=TRUE
#### Filtering ####
# The filtering keeps genes that have count-per-million (CPM) above k in n samples, where k is determined by min.count and by the sample library sizes and n is determined by the design matrix.
quantGenes <- rownames(cntEx)[filterByExpr(y[, seq.int(nsmpls)],
design=dsgn[seq.int(nsmpls), ]) & filterByExpr(y[, nsmpls + seq.int(nsmpls)],
design=dsgn[nsmpls + seq.int(nsmpls), ])]
pscnt <- 2
NLex <- cpm(y[, seq.int(nsmpls)], log=TRUE, prior.count=pscnt)
NLin <- cpm(y[, seq.int(nsmpls)], log=TRUE, prior.count=pscnt)
y <- y[quantGenes, ]
#### Design matrix and statistical model fitting ####
# Design matrix
cond2 <- rep(cond, 2L)
region <- factor(rep(c("ex", "in"), each=nsmpls),
levels=c("ex", "in"))
smpl <- factor(rep(sprintf("s%03d", seq.int(nsmpls)), 2)) # formatting strings
dsgn <- model.matrix(~ smpl)
c1.ex <- cond2 == levels(cond2)[1] & region == "ex"
c2.ex <- cond2 == levels(cond2)[2] & region == "ex"
dsgn <- cbind(dsgn, c1.ex, c2.ex)
rownames(dsgn) <- colnames(cnt)
# Fit statistical model
y <- estimateDisp(y, dsgn)
# Build contrast
contr <- (colnames(dsgn) == "c2.ex") - (colnames(dsgn) == "c1.ex")
# Quasi-likelihood F test
fit <- glmQLFit(y, dsgn)
tst.ExIn <- glmQLFTest(fit, contrast=contr)
tt.ExIn <- topTags(tst.ExIn, n=nrow(y), sort.by="none")
#### Calculate log-fold changes ####
lfc <- predFC(y, dsgn, prior.count=pscnt)
rownames(lfc) <- rownames(y)
# Changes in introns and/or exons between THAP vs. DMSO conditions
Dex <- rowSums(lfc[, c(3, 4)])
Din <- lfc[, 3]
Dex.Din <- lfc[, ncol(lfc)]
#### Visualisation ####
# Visualise design matrix
VisualizeDesign(
sampleData=data.frame(
treatment=str_extract(rownames(dsgn), "DMSO|THAP"),
ctype=str_extract(rownames(dsgn), "Ex|In"),
sample=gsub("Ex.|In.", "", rownames(dsgn)),
row.names=rownames(dsgn)
),
designFormula=NULL,
designMatrix=dsgn
)
ggplot(tt.ExIn$table, aes(x=logCPM, y=logFC)) +
geom_point(color="lightgrey") +
geom_point(data=tt.ExIn$table %>% filter(FDR < 0.05), color="red") +
theme_bw()
# Convert count tables to DGEList
cnt <- data.frame(Ex=cntEx, In=cntIn) # merge intron and exon count tables
y <- DGEList(counts=cnt,
genes=data.frame(ENTREZID=rownames(cnt)))
# Normalise for library size
y$samples$norm.factors.exons <- rep(calcNormFactors(cntEx), 2) # normalises library sizes by finding a set of scaling factors for the library sizes that minimizes log-fold changes between samples for most genes
y$samples$norm.factors.introns <- rep(calcNormFactors(cntIn), 2)
y$samples$norm.factors.individual <- calcNormFactors(y$counts)
y$samples$lib.size.exons <- rep(colSums(cntEx), 2)
y$samples$lib.size.introns <- rep(colSums(cntIn), 2)
y$samples$lib.size.individual <- colSums(y$counts)
#### Filtering ####
# The filtering keeps genes that have count-per-million (CPM) above k in n samples, where k is determined by min.count and by the sample library sizes and n is determined by the design matrix.
quantGenes <- rownames(cntEx)[filterByExpr(y[, seq.int(nsmpls)],
design=dsgn[seq.int(nsmpls), ]) & filterByExpr(y[, nsmpls + seq.int(nsmpls)],
design=dsgn[nsmpls + seq.int(nsmpls), ])]
pscnt <- 2
NLex <- cpm(y[, seq.int(nsmpls)], log=TRUE, prior.count=pscnt)
NLin <- cpm(y[, seq.int(nsmpls)], log=TRUE, prior.count=pscnt)
y <- y[quantGenes, ]
y$samples$norm.factors <- y$samples$norm.factors.exons # recalcNormFactAfterFilt=TRUE
# y$samples$lib.size <- y$samples$lib.size.exons # recalcLibSizeAfterFilt=TRUE
#### Design matrix and statistical model fitting ####
# Design matrix
cond2 <- rep(cond, 2L)
region <- factor(rep(c("ex", "in"), each=nsmpls),
levels=c("ex", "in"))
smpl <- factor(rep(sprintf("s%03d", seq.int(nsmpls)), 2)) # formatting strings
dsgn <- model.matrix(~ smpl)
c1.ex <- cond2 == levels(cond2)[1] & region == "ex"
c2.ex <- cond2 == levels(cond2)[2] & region == "ex"
dsgn <- cbind(dsgn, c1.ex, c2.ex)
rownames(dsgn) <- colnames(cnt)
# Fit statistical model
y <- estimateDisp(y, dsgn)
# Build contrast
contr <- (colnames(dsgn) == "c2.ex") - (colnames(dsgn) == "c1.ex")
# Quasi-likelihood F test
fit <- glmQLFit(y, dsgn)
tst.ExIn <- glmQLFTest(fit, contrast=contr)
tt.ExIn <- topTags(tst.ExIn, n=nrow(y), sort.by="none")
#### Calculate log-fold changes ####
lfc <- predFC(y, dsgn, prior.count=pscnt)
rownames(lfc) <- rownames(y)
# Changes in introns and/or exons between THAP vs. DMSO conditions
Dex <- rowSums(lfc[, c(3, 4)])
Din <- lfc[, 3]
Dex.Din <- lfc[, ncol(lfc)]
#### Visualisation ####
# Visualise design matrix
VisualizeDesign(
sampleData=data.frame(
treatment=str_extract(rownames(dsgn), "DMSO|THAP"),
ctype=str_extract(rownames(dsgn), "Ex|In"),
sample=gsub("Ex.|In.", "", rownames(dsgn)),
row.names=rownames(dsgn)
),
designFormula=NULL,
designMatrix=dsgn
)
ggplot(tt.ExIn$table, aes(x=logCPM, y=logFC)) +
geom_point(color="lightgrey") +
geom_point(data=tt.ExIn$table %>% filter(FDR < 0.05), color="red") +
theme_bw()
#### Load count files ####
exon <- read.table("processed/ExonicCounts_THAP_HEK.txt",
header=TRUE,
sep=" ",
row.names=1)
intron <- read.table("processed/IntronicCounts_THAP_HEK.txt",
header=TRUE,
sep=" ",
row.names=1)
# Remove "width" column
exon <- exon[, colnames(exon) != "width"]
intron <- intron[, colnames(intron) != "width"]
# Conditions
cond <- gsub("_RNAseq_rep[0-9]*.*", "", colnames(exon))
cond <- factor(cond, levels=unique(cond))
# Convert to matrix
cntEx <- as.matrix(exon)
cntIn <- as.matrix(intron)
# No. of samples
nsmpls <- ncol(cntEx)
# See fraction of introns
all <- exon + intron
fracInt <- colSums(intron) / colSums(all)
summary(fracInt)
#### Normalisation ####
# Convert count tables to DGEList
cnt <- data.frame(Ex=cntEx, In=cntIn) # merge intron and exon count tables
y <- DGEList(counts=cnt,
genes=data.frame(ENTREZID=rownames(cnt)))
# Normalise for library size
y$samples$norm.factors.exons <- rep(calcNormFactors(cntEx), 2) # normalises library sizes by finding a set of scaling factors for the library sizes that minimizes log-fold changes between samples for most genes
y$samples$norm.factors.introns <- rep(calcNormFactors(cntIn), 2)
y$samples$norm.factors.individual <- calcNormFactors(y$counts)
y$samples$lib.size.exons <- rep(colSums(cntEx), 2)
y$samples$lib.size.introns <- rep(colSums(cntIn), 2)
y$samples$lib.size.individual <- colSums(y$counts)
#### Filtering ####
# The filtering keeps genes that have count-per-million (CPM) above k in n samples, where k is determined by min.count and by the sample library sizes and n is determined by the design matrix.
quantGenes <- rownames(cntEx)[filterByExpr(y[, seq.int(nsmpls)],
design=dsgn[seq.int(nsmpls), ]) & filterByExpr(y[, nsmpls + seq.int(nsmpls)],
design=dsgn[nsmpls + seq.int(nsmpls), ])]
pscnt <- 2
NLex <- cpm(y[, seq.int(nsmpls)], log=TRUE, prior.count=pscnt)
NLin <- cpm(y[, seq.int(nsmpls)], log=TRUE, prior.count=pscnt)
y <- y[quantGenes, ]
# Re-normalisation (recalcNormFactAfterFilt=TRUE)
y$samples$norm.factors.exons <- rep(calcNormFactors(y$counts[, seq.int(nsmpls)]), 2)
y$samples$norm.factors.introns <- rep(calcNormFactors(y$counts[, nsmpls + seq.int(nsmpls)]), 2)
y$sample$norm.factors.individual <- calcNormFactors(y$counts)
y$samples$norm.factors <- y$samples$norm.factors.exons # sizeFactor="exons"
y$samples$lib.size <- y$samples$lib.size.exons # sizeFactor="exons"
NLex <- NLex[quantGenes, ]
NLin <- NLin[quantGenes, ]
#### Design matrix and statistical model fitting ####
# Design matrix
cond2 <- rep(cond, 2L)
region <- factor(rep(c("ex", "in"), each=nsmpls),
levels=c("ex", "in"))
smpl <- factor(rep(sprintf("s%03d", seq.int(nsmpls)), 2)) # formatting strings
dsgn <- model.matrix(~ smpl)
c1.ex <- cond2 == levels(cond2)[1] & region == "ex"
c2.ex <- cond2 == levels(cond2)[2] & region == "ex"
dsgn <- cbind(dsgn, c1.ex, c2.ex)
rownames(dsgn) <- colnames(cnt)
# Fit statistical model
y <- estimateDisp(y, dsgn)
# Build contrast
contr <- (colnames(dsgn) == "c2.ex") - (colnames(dsgn) == "c1.ex")
# Quasi-likelihood F test
fit <- glmQLFit(y, dsgn)
tst.ExIn <- glmQLFTest(fit, contrast=contr)
tt.ExIn <- topTags(tst.ExIn, n=nrow(y), sort.by="none")
#### Calculate log-fold changes ####
lfc <- predFC(y, dsgn, prior.count=pscnt)
rownames(lfc) <- rownames(y)
# Changes in introns and/or exons between THAP vs. DMSO conditions
Dex <- rowSums(lfc[, c(3, 4)])
Din <- lfc[, 3]
Dex.Din <- lfc[, ncol(lfc)]
#### Visualisation ####
# Visualise design matrix
VisualizeDesign(
sampleData=data.frame(
treatment=str_extract(rownames(dsgn), "DMSO|THAP"),
ctype=str_extract(rownames(dsgn), "Ex|In"),
sample=gsub("Ex.|In.", "", rownames(dsgn)),
row.names=rownames(dsgn)
),
designFormula=NULL,
designMatrix=dsgn
)
ggplot(tt.ExIn$table, aes(x=logCPM, y=logFC)) +
geom_point(color="lightgrey") +
geom_point(data=tt.ExIn$table %>% filter(FDR < 0.05), color="red") +
theme_bw()
ggplot(tt.ExIn$table, aes(x=logCPM, y=logFC)) +
geom_point(color="lightgrey") +
geom_point(data=tt.ExIn$table %>% filter(FDR < 0.05), color="red") +
theme_bw()
exon <- read.delim("/Users/Pomato/mrc/project/sita/processed/ExonicCounts_THAP_HEK.txt",
header=TRUE,
as.is=TRUE)
intron <- read.delim("/Users/Pomato/mrc/project/sita/processed/IntronicCounts_THAP_HEK.txt",
header=TRUE,
as.is=TRUE)
exon <- exon %>% select(c("Row.names", contains("_rep")))
#### Packages ####
library(edgeR)
library(eisaR)
library(ggplot2)
library(dplyr)
library(stringr)
#### Load counts files ####
exon <- read.delim("/Users/Pomato/mrc/project/sita/processed/ExonicCounts_THAP_HEK.txt",
header=TRUE,
as.is=TRUE)
intron <- read.delim("/Users/Pomato/mrc/project/sita/processed/IntronicCounts_THAP_HEK.txt",
header=TRUE,
as.is=TRUE)
exon <- exon %>% select(c("Row.names", contains("_rep")))
exon
head(exon)
exon <- exon %>% select(contains("_rep"))
exon
head(exon)
View(exon)
View(exon)
exon <- read.delim("/Users/Pomato/mrc/project/sita/processed/ExonicCounts_THAP_HEK.txt",
header=TRUE)
intron <- read.delim("/Users/Pomato/mrc/project/sita/processed/IntronicCounts_THAP_HEK.txt",
header=TRUE)
View(exon)
View(exon)
exon <- read.table("processed/ExonicCounts_THAP_HEK.txt",
header=TRUE,
sep=" ",
row.names=1)
intron <- read.table("processed/IntronicCounts_THAP_HEK.txt",
header=TRUE,
sep=" ",
row.names=1)
exon <- exon %>% select(contains("_rep"))
head(exon)
library(dplyr)
library(tibble)
exon <- read.table("processed/ExonicCounts_THAP_HEK.txt",
header=TRUE,
sep=" ",
row.names=1)
intron <- read.table("processed/IntronicCounts_THAP_HEK.txt",
header=TRUE,
sep=" ",
row.names=1)
exon <- exon %>%
select(contains("_rep")) %>%
as.matrix()
intron <- intron %>%
select(contains("_rep")) %>%
as.matrix()
dim(exon)
#### Packages ####
library(edgeR)
library(eisaR)
library(ggplot2)
library(dplyr)
library(ExploreModelMatrix)
library(stringr)
setwd("/Users/Pomato/mrc/project/sita")
#### Load count files ####
exon <- read.table("processed/ExonicCounts_THAP_HEK.txt",
header=TRUE,
sep=" ",
row.names=1)
intron <- read.table("processed/IntronicCounts_THAP_HEK.txt",
header=TRUE,
sep=" ",
row.names=1)
# Remove "width" column
exon <- exon[, colnames(exon) != "width"]
intron <- intron[, colnames(intron) != "width"]
# Conditions
cond <- gsub("_RNAseq_rep[0-9]*.*", "", colnames(exon))
cond <- factor(cond, levels=unique(cond))
# Convert to matrix
cntEx <- as.matrix(exon)
cntIn <- as.matrix(intron)
# No. of samples
nsmpls <- ncol(cntEx)
# See fraction of introns
all <- exon + intron
fracInt <- colSums(intron) / colSums(all)
summary(fracInt)
#### Normalisation ####
# Convert count tables to DGEList
cnt <- data.frame(Ex=cntEx, In=cntIn) # merge intron and exon count tables
y <- DGEList(counts=cnt,
genes=data.frame(ENTREZID=rownames(cnt)))
# Normalise for library size
y$samples$norm.factors.exons <- rep(calcNormFactors(cntEx), 2) # normalises library sizes by finding a set of scaling factors for the library sizes that minimizes log-fold changes between samples for most genes
y$samples$norm.factors.introns <- rep(calcNormFactors(cntIn), 2)
y$samples$norm.factors.individual <- calcNormFactors(y$counts)
y$samples$lib.size.exons <- rep(colSums(cntEx), 2)
y$samples$lib.size.introns <- rep(colSums(cntIn), 2)
y$samples$lib.size.individual <- colSums(y$counts)
#### Filtering ####
# The filtering keeps genes that have count-per-million (CPM) above k in n samples, where k is determined by min.count and by the sample library sizes and n is determined by the design matrix.
quantGenes <- rownames(cntEx)[filterByExpr(y[, seq.int(nsmpls)],
design=dsgn[seq.int(nsmpls), ]) &
filterByExpr(y[, nsmpls + seq.int(nsmpls)],
design=dsgn[nsmpls + seq.int(nsmpls), ])]
pscnt <- 2
NLex <- cpm(y[, seq.int(nsmpls)], log=TRUE, prior.count=pscnt)
NLin <- cpm(y[, seq.int(nsmpls)], log=TRUE, prior.count=pscnt)
y <- y[quantGenes, ]
NLex <- NLex[quantGenes, ]
NLin <- NLin[quantGenes, ]
# Re-normalisation (recalcNormFactAfterFilt=TRUE)
y$samples$norm.factors.exons <- rep(calcNormFactors(y$counts[, seq.int(nsmpls)]), 2)
y$samples$norm.factors.introns <- rep(calcNormFactors(y$counts[, nsmpls + seq.int(nsmpls)]), 2)
y$sample$norm.factors.individual <- calcNormFactors(y$counts)
y$samples$norm.factors <- y$samples$norm.factors.exons # sizeFactor="exons"
y$samples$lib.size <- y$samples$lib.size.exons # sizeFactor="exons"
#### Design matrix and statistical model fitting ####
# Design matrix
cond2 <- rep(cond, 2L)
region <- factor(rep(c("ex", "in"), each=nsmpls),
levels=c("ex", "in"))
smpl <- factor(rep(sprintf("s%03d", seq.int(nsmpls)), 2)) # formatting strings
dsgn <- model.matrix(~ smpl)
c1.ex <- cond2 == levels(cond2)[1] & region == "ex"
c2.ex <- cond2 == levels(cond2)[2] & region == "ex"
dsgn <- cbind(dsgn, c1.ex, c2.ex)
rownames(dsgn) <- colnames(cnt)
# Fit statistical model
y <- estimateDisp(y, dsgn)
# Build contrast
contr <- (colnames(dsgn) == "c2.ex") - (colnames(dsgn) == "c1.ex")
# Quasi-likelihood F test
fit <- glmQLFit(y, dsgn)
tst.ExIn <- glmQLFTest(fit, contrast=contr)
tt.ExIn <- topTags(tst.ExIn, n=nrow(y), sort.by="none")
#### Calculate log-fold changes ####
lfc <- predFC(y, dsgn, prior.count=pscnt)
rownames(lfc) <- rownames(y)
# Changes in introns and/or exons between THAP vs. DMSO conditions
Dex <- rowSums(lfc[, c(3, 4)])
Din <- lfc[, 3]
Dex.Din <- lfc[, ncol(lfc)]
#### Visualisation ####
# Visualise design matrix
VisualizeDesign(
sampleData=data.frame(
treatment=str_extract(rownames(dsgn), "DMSO|THAP"),
ctype=str_extract(rownames(dsgn), "Ex|In"),
sample=gsub("Ex.|In.", "", rownames(dsgn)),
row.names=rownames(dsgn)
),
designFormula=NULL,
designMatrix=dsgn
)
ggplot(tt.ExIn$table, aes(x=logCPM, y=logFC)) +
geom_point(color="lightgrey") +
geom_point(data=tt.ExIn$table %>% filter(FDR < 0.05), color="red") +
theme_bw()
# Top 10 genes with most significant fold change
head(tt.ExIn %>% arrange(FDR), 10)
head(tt.ExIn$table %>% arrange(FDR), 10)
dim(exon)
dim(intron)
shared <- intersect(rownames(exon), rownames(intron))
exonsh <- exon[shared, ]
intronsh <- intron[shared, ]
stopifnot(all(colnames(exonsh) == colnames(intronsh)))
res_eisar <- runEISA(cntEx=exonsh, cntIn=intronsh,
cond=gsub("_RNAseq_rep[0-9]*.*", "", colnames(exonsh)),
method=NULL,
modelSamples=TRUE,
geneSelection="filterByExpr",
statFramework="QLF",
effects="predFC",
pscnt=2,
recalcNormFactAfterFilt=TRUE,
recalcLibSizeAfterFilt=FALSE)
library(ExploreModelMatrix)
dm
dm <- res_eisar$designMatrix
dm
dm <- res_eisar$designMatrix
VisualizeDesign(
sampleData=data.frame(
treatment=str_extract(rownames(dm), "DMSO|THAP"),
ctype=str_extract(rownames(dm), "Ex|In"),
sample=gsub("Ex.|In.", "", rownames(dm)),
row.names=rownames(dm)
),
designFormula=NULL,
designMatrix=dm
)
res_eisar$contr.ExIn
ggplot(res_eisar$tab.ExIn, aes(x=logCPM, y=logFC)) +
geom_point(color="lightgrey") +
geom_point(data=res_eisar$tab.ExIn %>% filter(FDR < 0.05),
color="red") +
theme_bw()
head(res_eisar$tab.ExIn %>% arrange(FDR), 10)
gsub("_RNAseq_rep[0-9]*.*", "", colnames(exonsh))
cond <- gsub("_RNAseq_rep[0-9]*.*", "", colnames(exonsh))
install.packages("argparser")
library(argparser)
p <- arg_parser("Exon-Intron Split Analysis (EISA)")
p <- add_argument(p, "-e", help="path to exon counts file")
p <- add_argument(p, "-i", help="path to intron counts file")
args <- parse_args(p)
p <- arg_parser("Exon-Intron Split Analysis (EISA)")
p <- add_argument(p, "-e", help="path to exon counts file")
p <- add_argument(p, "-i", help="path to intron counts file")
args <- parse_args(p)
stopifnot(args$e && args$i)
p <- arg_parser("Exon-Intron Split Analysis (EISA)")
p <- add_argument(p, "-e", help="path to exon counts file")
p <- add_argument(p, "-i", help="path to intron counts file")
args <- parse_args(p)
stopifnot(args$e && args$i)
"abc" == TRUE
#### Packages ####
suppressPackageStartupMessages({
library(QuasR)
library(TxDb.Hsapiens.UCSC.hg18.knownGene)
library(argparser)
})
#### Parser ####
p <- arg_parser("QuasR alignment and counting for EISA")
p <- add_argument(p, "-i",
help="path to sample file")
p <- add_argument(p, "--stranded", action="store_true")
args <- parse_args(p)
help("add_argument")
p <- arg_parser("QuasR alignment and counting for EISA")
p <- add_argument(p, "-i",
help="path to sample file")
p <- add_argument(p, "--stranded", flag=TRUE)
args <- parse_args(p)
args$``
args
args$stranded
args$abb
