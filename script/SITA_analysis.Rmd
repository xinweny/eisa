---
title: "SITA Analysis with EISA and DESeq"
output: html_notebook
---
```{r setup, include=FALSE, echo=FALSE}
require("knitr")
opts_knit$set(root.dir="/Users/Pomato/mrc/project/sita/")
```


## Packages
```{r packages}
suppressPackageStartupMessages({
  library(eisaR)
  library(ggplot2)
  library(dplyr)
  library(glue)
  library(DESeq2)
})
```

## Load count data
Takes raw count tables of introns and exons obtained using the package QuasR. Details on how to obtain count tables for this analysis [here](https://rdrr.io/github/fmicompbio/eisaR/f/vignettes/eisaR.Rmd).
```{r load.data}
gse <- "GSE109834"
conditions <- c("PBS", "LPS") # control vs. treatment

exon <- read.table(glue("processed/ExonicCounts_{gse}.txt"), header=TRUE, sep="\t", row.names=1)
intron <- read.table(glue("processed/IntronicCounts_{gse}.txt"), header=TRUE, sep="\t", row.names=1)

exon <- exon %>% select(contains(conditions)) %>% as.matrix()
intron <- intron %>% select(contains(conditions)) %>% as.matrix()
```

## EISA
Run Exon Intron Split Analysis (EISA) on the raw intron and exon count tables for a certain GSE using . Outputs a MA plot that shows stress-induced transcriptional attenuation (SITA), a global downregulation in genes upon stress induction.
```{r eisa}
# Filter for genes which have ≥ 1 exon and intron
shared <- intersect(rownames(exon), rownames(intron))
exonsh <- exon[shared, ]
intronsh <- intron[shared, ]

message("No. of genes with ≥ 1 exon and intron: ", nrow(exonsh))

# Checks
allsh <- exonsh + intronsh
fracIn <- colSums(intronsh)/colSums(allsh)
summary(fracIn)

# Format and select conditions for each sample
cond <- gsub("_rep[0-9]*.*", "", colnames(exonsh))
stopifnot(all(colnames(exonsh) == colnames(intronsh)))

res_eisar <- runEISA(cntEx=exonsh, cntIn=intronsh,
                     cond=cond,
                     method=NULL,
                     modelSamples=TRUE,
                     geneSelection="filterByExpr",
                     statFramework="QLF",
                     effects="predFC",
                     pscnt=2,
                     recalcNormFactAfterFilt=TRUE,
                     recalcLibSizeAfterFilt=FALSE)

# Flip logFC
res_eisar$tab.ExIn$logFC <- -(res_eisar$tab.ExIn$logFC)

# EISA MA plot
MAplot <- ggplot(res_eisar$tab.ExIn, aes(x=logCPM, y=logFC)) +
  geom_point(color="lightgrey") +
  geom_point(data=res_eisar$tab.ExIn %>% filter(FDR < 0.05),
             color="red") +
  labs(title=glue("{conditions[1]} vs. {conditions[2]}"),
       subtitle=glue("UP={nrow(filter(res_eisar$tab.ExIn, FDR < 0.05 & logFC > 0))}, DOWN={nrow(filter(res_eisar$tab.ExIn, FDR < 0.05 & logFC < 0))}")) +
  theme_bw() +
  theme(plot.title=element_text(size=15, face="bold"),
        plot.subtitle=element_text())

MAplot

# Save output
png(glue("processed/eisaMAplot_{gse}_{conditions[1]}.{conditions[2]}.png"))
print(MAplot)
dev.off()
```

## DESeq2
Using the raw counts table for exons, the significant differentially expressed (DE) genes are determined with the package DESeq2.
```{r deseq}
# Make column metadata
cond <- gsub("_rep[0-9]*.*", "", colnames(exon))
colData <- data.frame(row.names=colnames(exon),
                      batch=seq.int(ncol(exon)),
                      condition=factor(cond, levels=conditions))

dataset <- DESeqDataSetFromMatrix(countData=exon,
                                  colData=colData,
                                  design= ~ batch + condition)

dataset <- dataset[rowSums(counts(dataset)) >= 10, ] # pre-filter genes with very few reads

## Run DESeq
dds <- DESeq(dataset)

res <- results(dds, contrast=c('condition', conditions), alpha=0.05)
res <- res[complete.cases(res), ] # remove any rows with NA

summary(res)
message("No. of significant DE genes (FDR < 0.05): ", sum(res$padj < 0.05, na.rm=TRUE))

# Save DESeq results table to output
res <- res[order(res$padj), ] # order by adjusted p-value
write.table(res,
            file=glue("processed/DESeq_{gse}_{conditions[1]}.{conditions[2]}.txt"),
            row.names=TRUE, col.names=TRUE, sep="\t")

## Visualisation
resLFC <- lfcShrink(dds, coef=resultsNames(dds)[3], type="apeglm")

# DESeq2 MA plot
DESeq2::plotMA(resLFC, main=glue("{conditions[1]} vs. {conditions[2]}"))
```

