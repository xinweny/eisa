summary(fracIn)
unique(format_condition(colnames(exon)))
# Normalisation
NLex <- log2(t(t(exon) / colSums(exon) * mean(colSums(exon))) + 8)
NLin <-log2(t(t(intron) / colSums(intron) * mean(colSums(intron))) + 8)
# Identify quantifiable genes
quantGenes <- rownames(exon)[ rowMeans(NLex) > 5.0 & rowMeans(NLin) > 5.0 ]
length(quantGenes)
#### Statistical analysis ####
library(edgeR)
# Create DGEList object with exonic and intronic counts
cntEx <- data.frame(exon)
cntIn <- data.frame(intron)
yEx <- DGEList(counts=cntEx, genes=data.frame(ENSEMBLID=rownames(cntEx)))
yIn <- DGEList(counts=cntIn, genes=data.frame(ENSEMBLID=rownames(cntIn)))
# Select quantifiable genes and normalise
yEx <- yEx[quantGenes, ]
yIn <- yIn[quantGenes, ]
yEx <- calcNormFactors(yEx)
yIn <- calcNormFactors(yIn)
yIn$samples$norm.factors <- yEx$samples$norm.factors # Set size factor for intronic counts to exonic size factors
# Design matrix with interaction term and batch effect
# region <- factor(c(rep("ex", 6), rep("in", 6)), levels = c("in", "ex"))
cond <- factor(c(rep(selectConditions[1], 3), rep(selectConditions[2], 3)),
levels=selectConditions)
batch <- factor(c(1, 3, 2, 1, 3, 2)) # c(1, 2, 3, 3, 1, 2) for None, c(1, 3, 2, 1, 3, 2) for HDGF
design <- model.matrix(~ batch + cond)
rownames(design) <- colnames(cntEx)
# Estimate model parameters
yEx <- estimateDisp(yEx, design)
yIn <- estimateDisp(yIn, design)
fitEx <- glmFit(yEx, design)
fitIn <- glmFit(yIn, design)
# Calculate likelihood-ratio between full and reduced models
lrtEx <- glmLRT(fitEx)
lrtIn <- glmLRT(fitIn)
# Create results table
ttEx <- topTags(lrtEx, n=nrow(yEx), sort.by="none")
ttIn <- topTags(lrtIn, n=nrow(yEx), sort.by="none")
head(ttEx$table[order(ttEx$table$FDR, decreasing=FALSE), ])
head(ttIn$table[order(ttIn$table$FDR, decreasing=FALSE), ])
#### Visualisation ####
nUpEx <- nrow(filter(ttEx$table, FDR < alpha & logFC > 0))
nDownEx <- nrow(filter(ttEx$table, FDR < alpha & logFC < 0))
ratioUpDownEx <- nUpEx / nDownEx
message("Ratio of up:down regulated genes (exonic): ", ratioUpDownEx)
nUpIn <- nrow(filter(ttIn$table, FDR < alpha & logFC > 0))
nDownIn <- nrow(filter(ttIn$table, FDR < alpha & logFC < 0))
ratioUpDownIn <- nUpIn / nDownIn
message("Ratio of up:down regulated genes (intronic): ", ratioUpDownIn)
# MA plot exonic
MAplot <- ggplot(ttEx$table, aes(x=logCPM, y=logFC)) +
geom_point(color="lightgrey") +
geom_point(data= ttEx$table %>% filter(FDR < alpha),
color="red") +
labs(title=glue("{unique(cond)[1]} vs. {unique(cond)[2]}, α={alpha} (Exonic)"),
caption=glue("UP={nUpEx}, DOWN={nDownEx}")) +
theme(panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),
panel.background=element_blank(),
axis.line=element_line(colour="black")) +
theme(plot.title=element_text(size=15, face="bold"),
plot.caption=element_text(size=15))
MAplot
# Save output
png(glue("processed/{gse}_eisaMAplot_{selectConditions[1]}.{selectConditions[2]}_exonic_{alpha}.png"))
print(MAplot)
dev.off()
# MA plot intronic
MAplot <- ggplot(ttIn$table, aes(x=logCPM, y=logFC)) +
geom_point(color="lightgrey") +
geom_point(data= ttIn$table %>% filter(FDR < alpha),
color="red") +
labs(title=glue("{unique(cond)[1]} vs. {unique(cond)[2]}, α={alpha} (Intronic)"),
caption=glue("UP={nUpIn}, DOWN={nDownIn}")) +
theme(panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),
panel.background=element_blank(),
axis.line=element_line(colour="black")) +
theme(plot.title=element_text(size=15, face="bold"),
plot.caption=element_text(size=15))
MAplot
# Save output
png(glue("processed/{gse}_eisaMAplot_{selectConditions[1]}.{selectConditions[2]}_intronic_{alpha}.png"))
print(MAplot)
dev.off()
gse <- "CUS000002"
selectConditions <- c("WT_HDGF", "R62_HDGF") # control vs. treatment
alpha <- 0.05
exon <- read.table(glue("processed/{gse}_ExonicCounts.txt"), header=TRUE, sep="\t", row.names=1, check.names=FALSE)
intron <- read.table(glue("processed/{gse}_IntronicCounts.txt"), header=TRUE, sep="\t", row.names=1, check.names=FALSE)
exon <- exon %>% dplyr::select(matches(selectConditions)) %>% as.matrix()
intron <- intron %>% dplyr::select(matches(selectConditions)) %>% as.matrix()
head(exon)
# Filter for genes which have ≥ 1 exon and intron
shared <- intersect(rownames(exon), rownames(intron))
exonsh <- exon[shared, ]
intronsh <- intron[shared, ]
message("No. of genes with ≥ 1 exon and intron: ", nrow(exonsh))
# Checks
allsh <- exonsh + intronsh
fracIn <- colSums(intronsh)/colSums(allsh)
summary(fracIn)
unique(format_condition(colnames(exon)))
# Normalisation
NLex <- log2(t(t(exon) / colSums(exon) * mean(colSums(exon))) + 8)
NLin <-log2(t(t(intron) / colSums(intron) * mean(colSums(intron))) + 8)
# Identify quantifiable genes
quantGenes <- rownames(exon)[ rowMeans(NLex) > 5.0 & rowMeans(NLin) > 5.0 ]
length(quantGenes)
#### Statistical analysis ####
library(edgeR)
# Create DGEList object with exonic and intronic counts
cntEx <- data.frame(exon)
cntIn <- data.frame(intron)
yEx <- DGEList(counts=cntEx, genes=data.frame(ENSEMBLID=rownames(cntEx)))
yIn <- DGEList(counts=cntIn, genes=data.frame(ENSEMBLID=rownames(cntIn)))
# Select quantifiable genes and normalise
yEx <- yEx[quantGenes, ]
yIn <- yIn[quantGenes, ]
yEx <- calcNormFactors(yEx)
yIn <- calcNormFactors(yIn)
yIn$samples$norm.factors <- yEx$samples$norm.factors # Set size factor for intronic counts to exonic size factors
# Design matrix with interaction term and batch effect
# region <- factor(c(rep("ex", 6), rep("in", 6)), levels = c("in", "ex"))
cond <- factor(c(rep(selectConditions[1], 3), rep(selectConditions[2], 3)),
levels=selectConditions)
batch <- factor(c(1, 3, 2, 1, 3, 2)) # c(1, 2, 3, 3, 1, 2) for None, c(1, 3, 2, 1, 3, 2) for HDGF
design <- model.matrix(~ batch + cond)
rownames(design) <- colnames(cntEx)
# Estimate model parameters
yEx <- estimateDisp(yEx, design)
yIn <- estimateDisp(yIn, design)
fitEx <- glmFit(yEx, design)
fitIn <- glmFit(yIn, design)
# Calculate likelihood-ratio between full and reduced models
lrtEx <- glmLRT(fitEx)
lrtIn <- glmLRT(fitIn)
# Create results table
ttEx <- topTags(lrtEx, n=nrow(yEx), sort.by="none")
ttIn <- topTags(lrtIn, n=nrow(yEx), sort.by="none")
head(ttEx$table[order(ttEx$table$FDR, decreasing=FALSE), ])
head(ttIn$table[order(ttIn$table$FDR, decreasing=FALSE), ])
#### Visualisation ####
nUpEx <- nrow(filter(ttEx$table, FDR < alpha & logFC > 0))
nDownEx <- nrow(filter(ttEx$table, FDR < alpha & logFC < 0))
ratioUpDownEx <- nUpEx / nDownEx
message("Ratio of up:down regulated genes (exonic): ", ratioUpDownEx)
nUpIn <- nrow(filter(ttIn$table, FDR < alpha & logFC > 0))
nDownIn <- nrow(filter(ttIn$table, FDR < alpha & logFC < 0))
ratioUpDownIn <- nUpIn / nDownIn
message("Ratio of up:down regulated genes (intronic): ", ratioUpDownIn)
# MA plot exonic
MAplot <- ggplot(ttEx$table, aes(x=logCPM, y=logFC)) +
geom_point(color="lightgrey") +
geom_point(data= ttEx$table %>% filter(FDR < alpha),
color="red") +
labs(title=glue("{unique(cond)[1]} vs. {unique(cond)[2]}, α={alpha} (Exonic)"),
caption=glue("UP={nUpEx}, DOWN={nDownEx}")) +
theme(panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),
panel.background=element_blank(),
axis.line=element_line(colour="black")) +
theme(plot.title=element_text(size=15, face="bold"),
plot.caption=element_text(size=15))
MAplot
# Save output
png(glue("processed/{gse}_eisaMAplot_{selectConditions[1]}.{selectConditions[2]}_exonic_{alpha}.png"))
print(MAplot)
dev.off()
# MA plot intronic
MAplot <- ggplot(ttIn$table, aes(x=logCPM, y=logFC)) +
geom_point(color="lightgrey") +
geom_point(data= ttIn$table %>% filter(FDR < alpha),
color="red") +
labs(title=glue("{unique(cond)[1]} vs. {unique(cond)[2]}, α={alpha} (Intronic)"),
caption=glue("UP={nUpIn}, DOWN={nDownIn}")) +
theme(panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),
panel.background=element_blank(),
axis.line=element_line(colour="black")) +
theme(plot.title=element_text(size=15, face="bold"),
plot.caption=element_text(size=15))
MAplot
# Save output
png(glue("processed/{gse}_eisaMAplot_{selectConditions[1]}.{selectConditions[2]}_intronic_{alpha}.png"))
print(MAplot)
dev.off()
require("knitr")
opts_knit$set(root.dir="~/mrc/project/sita_eisa/")
suppressPackageStartupMessages({
library(eisaR)
library(ggplot2)
library(dplyr)
library(glue)
library(DESeq2)
library(biomaRt)
})
add_ensembl_symbol <- function (table) {
genes <- row.names(table)
if (grepl("ENSG", genes[1], fixed=TRUE)) {
ensembl <- useMart("ensembl")
ensemblDataset <- "hsapiens_gene_ensembl"
symbol <- "hgnc_symbol"
filter <- "ensembl_gene_id"
} else if (grepl("ENSMUSG", genes[1], fixed=TRUE)) {
ensembl <- useMart("ensembl")
ensemblDataset <- "mmusculus_gene_ensembl"
symbol <- "mgi_symbol"
filter <- "ensembl_gene_id"
} else if (grepl("WBGene", genes[1], fixed=TRUE)) {
ensembl <- useMart(biomart = "parasite_mart",
host = "https://parasite.wormbase.org",
port = 443)
ensemblDataset <- "wbps_gene"
symbol <- "external_gene_id"
filter <- "wbps_gene_id"
}
mart <- useDataset(ensemblDataset, ensembl)
geneList <- getBM(filters=filter,
attributes=c(filter, symbol),
values=genes,
mart=mart) %>% distinct(ensembl_gene_id, .keep_all=TRUE)
row.names(geneList) <- geneList[, 1]
geneList[, 1] <- NULL
table$geneSymbol <- geneList[, 1][match(rownames(table), rownames(geneList))]
newTable <- table
return(newTable)
}
format_condition <- function (colnames) {
replace <- c("_[0-9]*$", "_rep[0-9]*$", "^[A-Z]{3}[0-9]+_", "^[0-9]+_")
for (r in replace) {
colnames <- gsub(r, "", colnames)
}
return(colnames)
}
gse <- "CUS000002"
selectConditions <- c("WT_None", "R62_None") # control vs. treatment
alpha <- 0.15
exon <- read.table(glue("processed/{gse}_ExonicCounts.txt"), header=TRUE, sep="\t", row.names=1, check.names=FALSE)
require("knitr")
opts_knit$set(root.dir="~/mrc/project/sita_eisa/")
gse <- "CUS000002"
selectConditions <- c("WT_None", "R62_None") # control vs. treatment
alpha <- 0.15
exon <- read.table(glue("processed/{gse}_ExonicCounts.txt"), header=TRUE, sep="\t", row.names=1, check.names=FALSE)
intron <- read.table(glue("processed/{gse}_IntronicCounts.txt"), header=TRUE, sep="\t", row.names=1, check.names=FALSE)
exon <- exon %>% dplyr::select(matches(selectConditions)) %>% as.matrix()
intron <- intron %>% dplyr::select(matches(selectConditions)) %>% as.matrix()
head(exon)
# Filter for genes which have ≥ 1 exon and intron
shared <- intersect(rownames(exon), rownames(intron))
exonsh <- exon[shared, ]
intronsh <- intron[shared, ]
message("No. of genes with ≥ 1 exon and intron: ", nrow(exonsh))
# Checks
allsh <- exonsh + intronsh
fracIn <- colSums(intronsh)/colSums(allsh)
summary(fracIn)
unique(format_condition(colnames(exon)))
# Normalisation
NLex <- log2(t(t(exon) / colSums(exon) * mean(colSums(exon))) + 8)
NLin <-log2(t(t(intron) / colSums(intron) * mean(colSums(intron))) + 8)
# Identify quantifiable genes
quantGenes <- rownames(exon)[ rowMeans(NLex) > 5.0 & rowMeans(NLin) > 5.0 ]
length(quantGenes)
#### Statistical analysis ####
library(edgeR)
# Create DGEList object with exonic and intronic counts
cntEx <- data.frame(exon)
cntIn <- data.frame(intron)
yEx <- DGEList(counts=cntEx, genes=data.frame(ENSEMBLID=rownames(cntEx)))
yIn <- DGEList(counts=cntIn, genes=data.frame(ENSEMBLID=rownames(cntIn)))
# Select quantifiable genes and normalise
yEx <- yEx[quantGenes, ]
yIn <- yIn[quantGenes, ]
yEx <- calcNormFactors(yEx)
yIn <- calcNormFactors(yIn)
yIn$samples$norm.factors <- yEx$samples$norm.factors # Set size factor for intronic counts to exonic size factors
# Design matrix with interaction term and batch effect
# region <- factor(c(rep("ex", 6), rep("in", 6)), levels = c("in", "ex"))
cond <- factor(c(rep(selectConditions[1], 3), rep(selectConditions[2], 3)),
levels=selectConditions)
batch <- factor(c(1, 2, 3, 3, 1, 2)) # c(1, 2, 3, 3, 1, 2) for None, c(1, 3, 2, 1, 3, 2) for HDGF
design <- model.matrix(~ batch + cond)
rownames(design) <- colnames(cntEx)
# Estimate model parameters
yEx <- estimateDisp(yEx, design)
yIn <- estimateDisp(yIn, design)
fitEx <- glmFit(yEx, design)
fitIn <- glmFit(yIn, design)
# Calculate likelihood-ratio between full and reduced models
lrtEx <- glmLRT(fitEx)
lrtIn <- glmLRT(fitIn)
# Create results table
ttEx <- topTags(lrtEx, n=nrow(yEx), sort.by="none")
ttIn <- topTags(lrtIn, n=nrow(yEx), sort.by="none")
head(ttEx$table[order(ttEx$table$FDR, decreasing=FALSE), ])
head(ttIn$table[order(ttIn$table$FDR, decreasing=FALSE), ])
#### Visualisation ####
nUpEx <- nrow(filter(ttEx$table, FDR < alpha & logFC > 0))
nDownEx <- nrow(filter(ttEx$table, FDR < alpha & logFC < 0))
ratioUpDownEx <- nUpEx / nDownEx
message("Ratio of up:down regulated genes (exonic): ", ratioUpDownEx)
nUpIn <- nrow(filter(ttIn$table, FDR < alpha & logFC > 0))
nDownIn <- nrow(filter(ttIn$table, FDR < alpha & logFC < 0))
ratioUpDownIn <- nUpIn / nDownIn
message("Ratio of up:down regulated genes (intronic): ", ratioUpDownIn)
# MA plot exonic
MAplot <- ggplot(ttEx$table, aes(x=logCPM, y=logFC)) +
geom_point(color="lightgrey") +
geom_point(data= ttEx$table %>% filter(FDR < alpha),
color="black", fill="red") +
labs(title=glue("{unique(cond)[1]} vs. {unique(cond)[2]}, α={alpha} (Exonic)"),
caption=glue("UP={nUpEx}, DOWN={nDownEx}")) +
theme(panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),
panel.background=element_blank(),
axis.line=element_line(colour="black")) +
theme(plot.title=element_text(size=15, face="bold"),
plot.caption=element_text(size=15))
MAplot
# Save output
png(glue("processed/{gse}_eisaMAplot_{selectConditions[1]}.{selectConditions[2]}_exonic_{alpha}.png"))
print(MAplot)
dev.off()
# MA plot intronic
MAplot <- ggplot(ttIn$table, aes(x=logCPM, y=logFC)) +
geom_point(color="lightgrey") +
geom_point(data= ttIn$table %>% filter(FDR < alpha),
color="black", fill="red") +
labs(title=glue("{unique(cond)[1]} vs. {unique(cond)[2]}, α={alpha} (Intronic)"),
caption=glue("UP={nUpIn}, DOWN={nDownIn}")) +
theme(panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),
panel.background=element_blank(),
axis.line=element_line(colour="black")) +
theme(plot.title=element_text(size=15, face="bold"),
plot.caption=element_text(size=15))
MAplot
# Save output
png(glue("processed/{gse}_eisaMAplot_{selectConditions[1]}.{selectConditions[2]}_intronic_{alpha}.png"))
print(MAplot)
dev.off()
# Normalisation
NLex <- log2(t(t(exon) / colSums(exon) * mean(colSums(exon))) + 8)
NLin <-log2(t(t(intron) / colSums(intron) * mean(colSums(intron))) + 8)
# Identify quantifiable genes
quantGenes <- rownames(exon)[ rowMeans(NLex) > 5.0 & rowMeans(NLin) > 5.0 ]
length(quantGenes)
#### Statistical analysis ####
library(edgeR)
# Create DGEList object with exonic and intronic counts
cntEx <- data.frame(exon)
cntIn <- data.frame(intron)
yEx <- DGEList(counts=cntEx, genes=data.frame(ENSEMBLID=rownames(cntEx)))
yIn <- DGEList(counts=cntIn, genes=data.frame(ENSEMBLID=rownames(cntIn)))
# Select quantifiable genes and normalise
yEx <- yEx[quantGenes, ]
yIn <- yIn[quantGenes, ]
yEx <- calcNormFactors(yEx)
yIn <- calcNormFactors(yIn)
yIn$samples$norm.factors <- yEx$samples$norm.factors # Set size factor for intronic counts to exonic size factors
# Design matrix with interaction term and batch effect
# region <- factor(c(rep("ex", 6), rep("in", 6)), levels = c("in", "ex"))
cond <- factor(c(rep(selectConditions[1], 3), rep(selectConditions[2], 3)),
levels=selectConditions)
batch <- factor(c(1, 2, 3, 3, 1, 2)) # c(1, 2, 3, 3, 1, 2) for None, c(1, 3, 2, 1, 3, 2) for HDGF
design <- model.matrix(~ batch + cond)
rownames(design) <- colnames(cntEx)
# Estimate model parameters
yEx <- estimateDisp(yEx, design)
yIn <- estimateDisp(yIn, design)
fitEx <- glmFit(yEx, design)
fitIn <- glmFit(yIn, design)
# Calculate likelihood-ratio between full and reduced models
lrtEx <- glmLRT(fitEx)
lrtIn <- glmLRT(fitIn)
# Create results table
ttEx <- topTags(lrtEx, n=nrow(yEx), sort.by="none")
ttIn <- topTags(lrtIn, n=nrow(yEx), sort.by="none")
head(ttEx$table[order(ttEx$table$FDR, decreasing=FALSE), ])
head(ttIn$table[order(ttIn$table$FDR, decreasing=FALSE), ])
#### Visualisation ####
nUpEx <- nrow(filter(ttEx$table, FDR < alpha & logFC > 0))
nDownEx <- nrow(filter(ttEx$table, FDR < alpha & logFC < 0))
ratioUpDownEx <- nUpEx / nDownEx
message("Ratio of up:down regulated genes (exonic): ", ratioUpDownEx)
nUpIn <- nrow(filter(ttIn$table, FDR < alpha & logFC > 0))
nDownIn <- nrow(filter(ttIn$table, FDR < alpha & logFC < 0))
ratioUpDownIn <- nUpIn / nDownIn
message("Ratio of up:down regulated genes (intronic): ", ratioUpDownIn)
# MA plot exonic
MAplot <- ggplot(ttEx$table, aes(x=logCPM, y=logFC)) +
geom_point(color="lightgrey") +
geom_point(data= ttEx$table %>% filter(FDR < alpha),
shape=21, color="black", fill="red") +
labs(title=glue("{unique(cond)[1]} vs. {unique(cond)[2]}, α={alpha} (Exonic)"),
caption=glue("UP={nUpEx}, DOWN={nDownEx}")) +
theme(panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),
panel.background=element_blank(),
axis.line=element_line(colour="black")) +
theme(plot.title=element_text(size=15, face="bold"),
plot.caption=element_text(size=15))
MAplot
# Save output
png(glue("processed/{gse}_eisaMAplot_{selectConditions[1]}.{selectConditions[2]}_exonic_{alpha}.png"))
print(MAplot)
dev.off()
# MA plot intronic
MAplot <- ggplot(ttIn$table, aes(x=logCPM, y=logFC)) +
geom_point(color="lightgrey") +
geom_point(data= ttIn$table %>% filter(FDR < alpha),
shape=21, color="black", fill="red") +
labs(title=glue("{unique(cond)[1]} vs. {unique(cond)[2]}, α={alpha} (Intronic)"),
caption=glue("UP={nUpIn}, DOWN={nDownIn}")) +
theme(panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),
panel.background=element_blank(),
axis.line=element_line(colour="black")) +
theme(plot.title=element_text(size=15, face="bold"),
plot.caption=element_text(size=15))
MAplot
# Save output
png(glue("processed/{gse}_eisaMAplot_{selectConditions[1]}.{selectConditions[2]}_intronic_{alpha}.png"))
print(MAplot)
dev.off()
# Normalisation
NLex <- log2(t(t(exon) / colSums(exon) * mean(colSums(exon))) + 8)
NLin <-log2(t(t(intron) / colSums(intron) * mean(colSums(intron))) + 8)
# Identify quantifiable genes
quantGenes <- rownames(exon)[ rowMeans(NLex) > 5.0 & rowMeans(NLin) > 5.0 ]
length(quantGenes)
#### Statistical analysis ####
library(edgeR)
# Create DGEList object with exonic and intronic counts
cntEx <- data.frame(exon)
cntIn <- data.frame(intron)
yEx <- DGEList(counts=cntEx, genes=data.frame(ENSEMBLID=rownames(cntEx)))
yIn <- DGEList(counts=cntIn, genes=data.frame(ENSEMBLID=rownames(cntIn)))
# Select quantifiable genes and normalise
yEx <- yEx[quantGenes, ]
yIn <- yIn[quantGenes, ]
yEx <- calcNormFactors(yEx)
yIn <- calcNormFactors(yIn)
yIn$samples$norm.factors <- yEx$samples$norm.factors # Set size factor for intronic counts to exonic size factors
# Design matrix with interaction term and batch effect
# region <- factor(c(rep("ex", 6), rep("in", 6)), levels = c("in", "ex"))
cond <- factor(c(rep(selectConditions[1], 3), rep(selectConditions[2], 3)),
levels=selectConditions)
batch <- factor(c(1, 2, 3, 3, 1, 2)) # c(1, 2, 3, 3, 1, 2) for None, c(1, 3, 2, 1, 3, 2) for HDGF
design <- model.matrix(~ batch + cond)
rownames(design) <- colnames(cntEx)
# Estimate model parameters
yEx <- estimateDisp(yEx, design)
yIn <- estimateDisp(yIn, design)
fitEx <- glmFit(yEx, design)
fitIn <- glmFit(yIn, design)
# Calculate likelihood-ratio between full and reduced models
lrtEx <- glmLRT(fitEx)
lrtIn <- glmLRT(fitIn)
# Create results table
ttEx <- topTags(lrtEx, n=nrow(yEx), sort.by="none")
ttIn <- topTags(lrtIn, n=nrow(yEx), sort.by="none")
head(ttEx$table[order(ttEx$table$FDR, decreasing=FALSE), ])
head(ttIn$table[order(ttIn$table$FDR, decreasing=FALSE), ])
#### Visualisation ####
nUpEx <- nrow(filter(ttEx$table, FDR < alpha & logFC > 0))
nDownEx <- nrow(filter(ttEx$table, FDR < alpha & logFC < 0))
ratioUpDownEx <- nUpEx / nDownEx
message("Ratio of up:down regulated genes (exonic): ", ratioUpDownEx)
nUpIn <- nrow(filter(ttIn$table, FDR < alpha & logFC > 0))
nDownIn <- nrow(filter(ttIn$table, FDR < alpha & logFC < 0))
ratioUpDownIn <- nUpIn / nDownIn
message("Ratio of up:down regulated genes (intronic): ", ratioUpDownIn)
# MA plot exonic
MAplot <- ggplot(ttEx$table, aes(x=logCPM, y=logFC)) +
geom_point(shape=21, color="black", fill="lightgrey") +
geom_point(data= ttEx$table %>% filter(FDR < alpha),
shape=21, color="black", fill="red") +
labs(title=glue("{unique(cond)[1]} vs. {unique(cond)[2]}, α={alpha} (Exonic)"),
caption=glue("UP={nUpEx}, DOWN={nDownEx}")) +
theme(panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),
panel.background=element_blank(),
axis.line=element_line(colour="black")) +
theme(plot.title=element_text(size=15, face="bold"),
plot.caption=element_text(size=15))
MAplot
# Save output
png(glue("processed/{gse}_eisaMAplot_{selectConditions[1]}.{selectConditions[2]}_exonic_{alpha}.png"))
print(MAplot)
dev.off()
# MA plot intronic
MAplot <- ggplot(ttIn$table, aes(x=logCPM, y=logFC)) +
geom_point(shape=21, color="black", fill="lightgrey") +
geom_point(data= ttIn$table %>% filter(FDR < alpha),
shape=21, color="black", fill="red") +
labs(title=glue("{unique(cond)[1]} vs. {unique(cond)[2]}, α={alpha} (Intronic)"),
caption=glue("UP={nUpIn}, DOWN={nDownIn}")) +
theme(panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),
panel.background=element_blank(),
axis.line=element_line(colour="black")) +
theme(plot.title=element_text(size=15, face="bold"),
plot.caption=element_text(size=15))
MAplot
# Save output
png(glue("processed/{gse}_eisaMAplot_{selectConditions[1]}.{selectConditions[2]}_intronic_{alpha}.png"))
print(MAplot)
dev.off()
